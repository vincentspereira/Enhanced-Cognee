"""
Comprehensive Unit Tests for ALL 60+ MCP Tools in Enhanced Cognee MCP Server

Tests EVERY tool with:
1. Happy path - normal operation
2. Edge cases - boundary values, empty inputs, special characters
3. Error cases - missing parameters, invalid data types
4. Integration - database interactions
5. ASCII output - no Unicode in messages

Coverage Target: 98%+
"""

import pytest
import asyncio
import json
import uuid
from datetime import datetime, UTC
from unittest.mock import AsyncMock, Mock, MagicMock, patch
from typing import Dict, Any


# ============================================================================
# Helper Functions
# ============================================================================

def create_mock_acquire_context(mock_conn):
    """Create a proper async context manager for postgres_pool.acquire()"""
    class MockAcquireContext:
        async def __aenter__(self):
            return mock_conn
        async def __aexit__(self, *args):
            pass
    return MockAcquireContext()


def create_async_mock_return(value):
    """Create an async function that returns a value (avoids coroutine issues)"""
    async def _return():
        return value
    return _return


def assert_ascii_only(text: str, field_name: str = "output"):
    """Assert text contains only ASCII characters (no Unicode)"""
    try:
        text.encode('ascii')
    except UnicodeEncodeError as e:
        pytest.fail(f"Non-ASCII character found in {field_name}: {e}\nText: {text}")


def create_mock_memory(memory_id: str = None, content: str = "Test content", title: str = "Test Memory") -> Dict:
    """Create a mock memory dictionary matching the actual database schema"""
    return {
        "id": memory_id or str(uuid.uuid4()),
        "title": title,
        "content": content,
        "agent_id": "test-agent",
        "user_id": "test-user",
        "created_at": datetime.now(UTC).isoformat(),
        "metadata": {}
    }


# ============================================================================
# Test Fixtures
# ============================================================================

@pytest.fixture
def mock_global_instances(monkeypatch):
    """Mock all global module instances"""
    import sys
    from pathlib import Path
    from unittest.mock import MagicMock

    # Add project to path
    project_root = Path(__file__).parent.parent.parent
    sys.path.insert(0, str(project_root))
    sys.path.insert(0, str(project_root / "bin"))

    # Mock the source modules BEFORE importing server
    sys.modules['src.memory_management'] = MagicMock()
    sys.modules['src.memory_deduplication'] = MagicMock()
    sys.modules['src.memory_summarization'] = MagicMock()
    sys.modules['src.performance_analytics'] = MagicMock()
    sys.modules['src.cross_agent_sharing'] = MagicMock()
    sys.modules['src.realtime_sync'] = MagicMock()
    sys.modules['src.language_detector'] = MagicMock()
    sys.modules['src.multi_language_search'] = MagicMock()
    sys.modules['src.intelligent_summarization'] = MagicMock()
    sys.modules['src.advanced_search_reranking'] = MagicMock()
    sys.modules['src.backup_manager'] = MagicMock()
    sys.modules['src.recovery_manager'] = MagicMock()
    sys.modules['src.maintenance_scheduler'] = MagicMock()
    sys.modules['src.scheduled_deduplication'] = MagicMock()
    sys.modules['src.scheduled_summarization'] = MagicMock()

    # Mock all database connections
    mock_postgres = Mock()
    mock_qdrant = Mock()
    mock_neo4j = Mock()
    mock_redis = AsyncMock()

    # Mock all module instances
    mock_memory_manager = AsyncMock()
    mock_deduplicator = AsyncMock()
    mock_summarizer = AsyncMock()
    mock_performance = AsyncMock()
    mock_cross_agent = AsyncMock()
    mock_realtime = AsyncMock()
    mock_lang_detector = Mock()
    mock_multi_lang = AsyncMock()
    mock_intelligent_summarizer = AsyncMock()
    mock_advanced_search = AsyncMock()
    mock_backup_manager = AsyncMock()
    mock_recovery_manager = AsyncMock()
    mock_maintenance_scheduler = AsyncMock()
    mock_scheduled_deduplication = AsyncMock()
    mock_scheduled_summarization = AsyncMock()

    # Import and patch server module
    import enhanced_cognee_mcp_server as server

    monkeypatch.setattr(server, 'postgres_pool', mock_postgres)
    monkeypatch.setattr(server, 'qdrant_client', mock_qdrant)
    monkeypatch.setattr(server, 'neo4j_driver', mock_neo4j)
    monkeypatch.setattr(server, 'redis_client', mock_redis)
    monkeypatch.setattr(server, 'memory_manager', mock_memory_manager)
    monkeypatch.setattr(server, 'memory_deduplicator', mock_deduplicator)
    monkeypatch.setattr(server, 'memory_summarizer', mock_summarizer)
    monkeypatch.setattr(server, 'performance_analytics', mock_performance)
    monkeypatch.setattr(server, 'cross_agent_sharing', mock_cross_agent)
    monkeypatch.setattr(server, 'realtime_sync', mock_realtime)
    monkeypatch.setattr(server, 'language_detector_instance', mock_lang_detector)
    monkeypatch.setattr(server, 'multi_language_search_instance', mock_multi_lang)
    monkeypatch.setattr(server, 'intelligent_summarizer', mock_intelligent_summarizer)
    monkeypatch.setattr(server, 'advanced_search_engine', mock_advanced_search)
    monkeypatch.setattr(server, 'backup_manager', mock_backup_manager)
    monkeypatch.setattr(server, 'recovery_manager', mock_recovery_manager)
    monkeypatch.setattr(server, 'maintenance_scheduler', mock_maintenance_scheduler)
    monkeypatch.setattr(server, 'scheduled_deduplication', mock_scheduled_deduplication)
    monkeypatch.setattr(server, 'scheduled_summarization', mock_scheduled_summarization)

    return server


@pytest.fixture
def mock_postgres_conn():
    """Mock PostgreSQL connection"""
    mock_conn = AsyncMock()
    mock_conn.fetch = AsyncMock(return_value=[])
    mock_conn.fetchrow = AsyncMock(return_value=None)
    mock_conn.fetchval = AsyncMock(return_value=1)
    mock_conn.execute = AsyncMock(return_value=None)
    return mock_conn


# ============================================================================
# 1. Standard Memory Tools (7 tools)
# ============================================================================

class TestStandardMemoryTools:
    """Test standard memory MCP tools for Claude Code integration"""

    @pytest.mark.asyncio
    async def test_add_memory_happy_path(self, mock_global_instances, mock_postgres_conn):
        """Test add_memory with valid inputs"""
        server = mock_global_instances

        # Mock database responses
        mock_postgres_conn.fetchval.return_value = "test-memory-id"
        server.postgres_pool.acquire = Mock(return_value=create_mock_acquire_context(mock_postgres_conn))

        # Mock deduplicator to return no duplicate
        server.memory_deduplicator.check_duplicate = AsyncMock(return_value={"is_duplicate": False})

        # Mock memory manager
        server.memory_manager.add_memory = AsyncMock(return_value="test-memory-id")

        # Call tool
        result = await server.add_memory(
            content="Test memory content",
            user_id="test-user",
            agent_id="test-agent"
        )

        # Verify result
        assert "OK" in result or "test-memory-id" in result
        assert_ascii_only(result, "add_memory output")

    @pytest.mark.asyncio
    async def test_add_memory_with_metadata(self, mock_global_instances, mock_postgres_conn):
        """Test add_memory with JSON metadata"""
        server = mock_global_instances

        mock_postgres_conn.fetchval.return_value = "test-memory-id"
        server.postgres_pool.acquire = Mock(return_value=create_mock_acquire_context(mock_postgres_conn))
        server.memory_deduplicator.check_duplicate = AsyncMock(return_value={"is_duplicate": False})
        server.memory_manager.add_memory = AsyncMock(return_value="test-memory-id")

        metadata = json.dumps({"category": "test", "priority": "high"})

        result = await server.add_memory(
            content="Test memory with metadata",
            metadata=metadata
        )

        assert "OK" in result or "test-memory-id" in result
        assert_ascii_only(result)

    @pytest.mark.asyncio
    async def test_add_memory_duplicate_prevention(self, mock_global_instances):
        """Test add_memory prevents duplicates"""
        server = mock_global_instances

        # Mock deduplicator to detect duplicate
        server.memory_deduplicator.check_duplicate = AsyncMock(return_value={
            "is_duplicate": True,
            "reason": "Exact duplicate found",
            "existing_id": "existing-memory-123"
        })

        result = await server.add_memory(
            content="Duplicate content",
            agent_id="test-agent"
        )

        assert "Duplicate" in result or "duplicate" in result
        assert_ascii_only(result)

    @pytest.mark.asyncio
    async def test_add_memory_empty_content(self, mock_global_instances):
        """Test add_memory with empty content"""
        server = mock_global_instances

        server.memory_deduplicator.check_duplicate = AsyncMock(return_value={"is_duplicate": False})

        result = await server.add_memory(content="")

        # Should handle gracefully
        assert_ascii_only(result)

    @pytest.mark.asyncio
    async def test_add_memory_special_characters(self, mock_global_instances, mock_postgres_conn):
        """Test add_memory with special characters"""
        server = mock_global_instances

        mock_postgres_conn.fetchval.return_value = "test-memory-id"
        server.postgres_pool.acquire = Mock(return_value=create_mock_acquire_context(mock_postgres_conn))
        server.memory_deduplicator.check_duplicate = AsyncMock(return_value={"is_duplicate": False})
        server.memory_manager.add_memory = AsyncMock(return_value="test-memory-id")

        special_content = "Test with special chars: !@#$%^&*()[]{}|\\:;\"'<>?,./"

        result = await server.add_memory(content=special_content)

        assert "OK" in result or "test-memory-id" in result
        assert_ascii_only(result)

    @pytest.mark.asyncio
    async def test_add_memory_no_database(self, mock_global_instances):
        """Test add_memory when database not available"""
        server = mock_global_instances

        # Set database to None
        server.postgres_pool = None

        result = await server.add_memory(content="Test content")

        assert "ERR" in result
        assert "not available" in result.lower() or "cannot" in result.lower()
        assert_ascii_only(result)

    @pytest.mark.asyncio
    async def test_search_memories_happy_path(self, mock_global_instances, mock_postgres_conn):
        """Test search_memories with valid query"""
        server = mock_global_instances

        # Mock search results
        mock_results = [
            create_mock_memory("mem-1", "Result 1"),
            create_mock_memory("mem-2", "Result 2")
        ]
        mock_postgres_conn.fetch = AsyncMock(return_value=mock_results)
        server.postgres_pool.acquire = Mock(return_value=create_mock_acquire_context(mock_postgres_conn))

        result = await server.search_memories(query="test query", limit=10)

        assert_ascii_only(result)
        assert "mem-1" in result or "Result" in result

    @pytest.mark.asyncio
    async def test_search_memories_empty_query(self, mock_global_instances):
        """Test search_memories with empty query"""
        server = mock_global_instances

        result = await server.search_memories(query="")

        assert_ascii_only(result)

    @pytest.mark.asyncio
    async def test_search_memories_limit_boundary(self, mock_global_instances, mock_postgres_conn):
        """Test search_memories with various limit values"""
        server = mock_global_instances

        mock_postgres_conn.fetch = AsyncMock(return_value=[])
        server.postgres_pool.acquire = Mock(return_value=create_mock_acquire_context(mock_postgres_conn))

        # Test limit = 1 (minimum)
        result1 = await server.search_memories(query="test", limit=1)
        assert_ascii_only(result1)

        # Test limit = 100 (maximum)
        result2 = await server.search_memories(query="test", limit=100)
        assert_ascii_only(result2)

        # Test limit = 0 (edge case)
        result3 = await server.search_memories(query="test", limit=0)
        assert_ascii_only(result3)

    @pytest.mark.asyncio
    async def test_search_memories_unicode_query(self, mock_global_instances):
        """Test search_memories handles Unicode in query gracefully"""
        server = mock_global_instances

        # Unicode characters should be handled without crashes
        result = await server.search_memories(query="test with unicode: \u2713\u2717")

        # Output should still be ASCII
        assert_ascii_only(result)

    @pytest.mark.asyncio
    async def test_get_memories_happy_path(self, mock_global_instances, mock_postgres_conn):
        """Test get_memories retrieves memories"""
        server = mock_global_instances

        mock_memories = [
            create_mock_memory("mem-1", "Memory 1"),
            create_mock_memory("mem-2", "Memory 2")
        ]
        mock_postgres_conn.fetch = AsyncMock(return_value=mock_memories)
        server.postgres_pool.acquire = Mock(return_value=create_mock_acquire_context(mock_postgres_conn))

        result = await server.get_memories(agent_id="test-agent", limit=50)

        assert_ascii_only(result)
        assert "mem-1" in result or "Memory" in result

    @pytest.mark.asyncio
    async def test_get_memories_no_filter(self, mock_global_instances, mock_postgres_conn):
        """Test get_memories without filters"""
        server = mock_global_instances

        mock_postgres_conn.fetch = AsyncMock(return_value=[])
        server.postgres_pool.acquire = Mock(return_value=create_mock_acquire_context(mock_postgres_conn))

        result = await server.get_memories()

        assert_ascii_only(result)

    @pytest.mark.asyncio
    async def test_get_memory_happy_path(self, mock_global_instances, mock_postgres_conn):
        """Test get_memory retrieves specific memory"""
        server = mock_global_instances

        mock_memory = create_mock_memory("test-id", "Specific memory content")
        mock_postgres_conn.fetchrow = AsyncMock(return_value=mock_memory)
        server.postgres_pool.acquire = Mock(return_value=create_mock_acquire_context(mock_postgres_conn))

        result = await server.get_memory(memory_id="test-id")

        assert_ascii_only(result)
        assert "test-id" in result or "Specific memory" in result

    @pytest.mark.asyncio
    async def test_get_memory_not_found(self, mock_global_instances, mock_postgres_conn):
        """Test get_memory with non-existent ID"""
        server = mock_global_instances

        mock_postgres_conn.fetchrow = AsyncMock(return_value=None)
        server.postgres_pool.acquire = Mock(return_value=create_mock_acquire_context(mock_postgres_conn))

        result = await server.get_memory(memory_id="non-existent-id")

        assert_ascii_only(result)
        assert "not found" in result.lower() or "ERR" in result

    @pytest.mark.asyncio
    async def test_get_memory_empty_id(self, mock_global_instances):
        """Test get_memory with empty ID"""
        server = mock_global_instances

        result = await server.get_memory(memory_id="")

        assert_ascii_only(result)

    @pytest.mark.asyncio
    async def test_update_memory_happy_path(self, mock_global_instances, mock_postgres_conn):
        """Test update_memory updates existing memory"""
        server = mock_global_instances

        mock_postgres_conn.fetchval = AsyncMock(return_value=1)  # 1 row updated
        server.postgres_pool.acquire = Mock(return_value=create_mock_acquire_context(mock_postgres_conn))

        result = await server.update_memory(
            memory_id="test-id",
            content="Updated content"
        )

        assert_ascii_only(result)
        assert "OK" in result or "updated" in result.lower()

    @pytest.mark.asyncio
    async def test_update_memory_not_found(self, mock_global_instances, mock_postgres_conn):
        """Test update_memory with non-existent ID"""
        server = mock_global_instances

        mock_postgres_conn.fetchval = AsyncMock(return_value=0)  # 0 rows updated
        server.postgres_pool.acquire = Mock(return_value=create_mock_acquire_context(mock_postgres_conn))

        result = await server.update_memory(
            memory_id="non-existent-id",
            content="New content"
        )

        assert_ascii_only(result)
        assert "not found" in result.lower() or "ERR" in result

    @pytest.mark.asyncio
    async def test_delete_memory_happy_path(self, mock_global_instances, mock_postgres_conn):
        """Test delete_memory removes memory"""
        server = mock_global_instances

        mock_postgres_conn.fetchval = AsyncMock(return_value=1)  # 1 row deleted
        server.postgres_pool.acquire = Mock(return_value=create_mock_acquire_context(mock_postgres_conn))

        result = await server.delete_memory(memory_id="test-id")

        assert_ascii_only(result)
        assert "OK" in result or "deleted" in result.lower()

    @pytest.mark.asyncio
    async def test_delete_memory_not_found(self, mock_global_instances, mock_postgres_conn):
        """Test delete_memory with non-existent ID"""
        server = mock_global_instances

        mock_postgres_conn.fetchval = AsyncMock(return_value=0)  # 0 rows deleted
        server.postgres_pool.acquire = Mock(return_value=create_mock_acquire_context(mock_postgres_conn))

        result = await server.delete_memory(memory_id="non-existent-id")

        assert_ascii_only(result)

    @pytest.mark.asyncio
    async def test_list_agents_happy_path(self, mock_global_instances, mock_postgres_conn):
        """Test list_agents returns all agents"""
        server = mock_global_instances

        mock_agents = [
            {"agent_id": "agent-1", "memory_count": 10},
            {"agent_id": "agent-2", "memory_count": 20}
        ]
        mock_postgres_conn.fetch = AsyncMock(return_value=mock_agents)
        server.postgres_pool.acquire = Mock(return_value=create_mock_acquire_context(mock_postgres_conn))

        result = await server.list_agents()

        assert_ascii_only(result)
        assert "agent-1" in result or "agent-2" in result

    @pytest.mark.asyncio
    async def test_list_agents_empty(self, mock_global_instances, mock_postgres_conn):
        """Test list_agents when no agents exist"""
        server = mock_global_instances

        mock_postgres_conn.fetch = AsyncMock(return_value=[])
        server.postgres_pool.acquire = Mock(return_value=create_mock_acquire_context(mock_postgres_conn))

        result = await server.list_agents()

        assert_ascii_only(result)


# ============================================================================
# 2. Enhanced Cognee Tools (5 tools)
# ============================================================================

class TestEnhancedCogneeTools:
    """Test Enhanced Cognee core functionality tools"""

    @pytest.mark.asyncio
    async def test_cognify_happy_path(self, mock_global_instances, mock_postgres_conn):
        """Test cognify processes data correctly"""
        server = mock_global_instances

        mock_postgres_conn.fetchval = AsyncMock(return_value="doc-123")
        server.postgres_pool.acquire = Mock(return_value=create_mock_acquire_context(mock_postgres_conn))

        result = await server.cognify(data="Test data to cognify")

        assert_ascii_only(result)
        assert "OK" in result or "doc-123" in result

    @pytest.mark.asyncio
    async def test_cognify_empty_data(self, mock_global_instances):
        """Test cognify with empty data"""
        server = mock_global_instances

        result = await server.cognify(data="")

        assert_ascii_only(result)

    @pytest.mark.asyncio
    async def test_cognify_large_data(self, mock_global_instances, mock_postgres_conn):
        """Test cognify with large data"""
        server = mock_global_instances

        mock_postgres_conn.fetchval = AsyncMock(return_value="doc-large")
        server.postgres_pool.acquire = Mock(return_value=create_mock_acquire_context(mock_postgres_conn))

        large_data = "Test data " * 1000  # ~11KB

        result = await server.cognify(data=large_data)

        assert_ascii_only(result)

    @pytest.mark.asyncio
    async def test_search_happy_path(self, mock_global_instances):
        """Test search queries knowledge graph"""
        server = mock_global_instances

        # Mock search results
        server.qdrant_client.search = Mock(return_value=[
            {"id": "1", "score": 0.9, "payload": {"content": "Result 1"}}
        ])

        result = await server.search(query="test query", limit=10)

        assert_ascii_only(result)

    @pytest.mark.asyncio
    async def test_search_empty_query(self, mock_global_instances):
        """Test search with empty query"""
        server = mock_global_instances

        result = await server.search(query="")

        assert_ascii_only(result)

    @pytest.mark.asyncio
    async def test_list_data_happy_path(self, mock_global_instances, mock_postgres_conn):
        """Test list_data returns all documents"""
        server = mock_global_instances

        mock_docs = [
            {"id": "doc-1", "title": "Document 1", "created_at": datetime.now(UTC)},
            {"id": "doc-2", "title": "Document 2", "created_at": datetime.now(UTC)}
        ]
        mock_postgres_conn.fetch = AsyncMock(return_value=mock_docs)
        server.postgres_pool.acquire = Mock(return_value=create_mock_acquire_context(mock_postgres_conn))

        result = await server.list_data()

        assert_ascii_only(result)
        assert "doc-1" in result or "Document" in result

    @pytest.mark.asyncio
    async def test_get_stats_happy_path(self, mock_global_instances, mock_postgres_conn):
        """Test get_stats returns system statistics"""
        server = mock_global_instances

        # Mock database responses
        mock_postgres_conn.fetchval = AsyncMock(return_value=10)
        server.postgres_pool.acquire = Mock(return_value=create_mock_acquire_context(mock_postgres_conn))
        server.qdrant_client.get_collections = Mock(return_value=Mock(collections=[]))

        result = await server.get_stats()

        assert_ascii_only(result)
        assert "Enhanced Cognee" in result or "status" in result.lower()

    @pytest.mark.asyncio
    async def test_health_happy_path(self, mock_global_instances):
        """Test health checks all database connections"""
        server = mock_global_instances

        # Mock health checks
        mock_postgres_conn.fetchval = AsyncMock(return_value=1)
        server.postgres_pool.acquire = Mock(return_value=create_mock_acquire_context(mock_postgres_conn))
        server.qdrant_client.get_collections = Mock(return_value=Mock(collections=[]))
        server.redis_client.ping = AsyncMock(return_value=True)

        result = await server.health()

        assert_ascii_only(result)
        assert "PostgreSQL" in result or "Qdrant" in result or "Redis" in result


# ============================================================================
# 3. Memory Management Tools (4 tools)
# ============================================================================

class TestMemoryManagementTools:
    """Test memory management and lifecycle tools"""

    @pytest.mark.asyncio
    async def test_expire_memories_happy_path(self, mock_global_instances, monkeypatch):
        """Test expire_memories removes old memories"""
        server = mock_global_instances

        # Mock get_memory_age_stats to return a string (not a coroutine)
        async def mock_get_age_stats():
            return "OK Memory age stats: avg=45 days"

        import enhanced_cognee_mcp_server as server_module
        monkeypatch.setattr(server_module, 'get_memory_age_stats', mock_get_age_stats)

        # Create a coroutine that returns the expected value
        async def mock_expire(days=None, dry_run=None, policy=None):
            return {
                "status": "success",
                "memories_affected": 10,
                "expired_count": 10,
                "freed_space_bytes": 1024
            }

        server.memory_manager.expire_old_memories = mock_expire

        result = await server.expire_memories(days=90, dry_run=False)

        assert_ascii_only(result)
        assert "10" in result or "expired" in result.lower()

    @pytest.mark.asyncio
    async def test_expire_memories_dry_run(self, mock_global_instances, monkeypatch):
        """Test expire_memories in dry-run mode"""
        server = mock_global_instances

        # Mock get_memory_age_stats to return a string (not a coroutine)
        async def mock_get_age_stats():
            return "OK Memory age stats: avg=45 days"

        import enhanced_cognee_mcp_server as server_module
        monkeypatch.setattr(server_module, 'get_memory_age_stats', mock_get_age_stats)

        async def mock_expire(days=None, dry_run=None, policy=None):
            return {
                "status": "dry_run",
                "memories_affected": 5,
                "expired_count": 5,
                "freed_space_bytes": 512
            }

        server.memory_manager.expire_old_memories = mock_expire

        result = await server.expire_memories(days=90, dry_run=True)

        assert_ascii_only(result)
        assert "dry" in result.lower() or "preview" in result.lower()

    @pytest.mark.asyncio
    async def test_expire_memories_boundary_values(self, mock_global_instances):
        """Test expire_memories with boundary days values"""
        server = mock_global_instances

        async def mock_expire(days=None, dry_run=None, policy=None):
            return {
                "expired_count": 0,
                "freed_space_bytes": 0
            }

        server.memory_manager.expire_old_memories = mock_expire

        # Test days = 1 (minimum)
        result1 = await server.expire_memories(days=1)
        assert_ascii_only(result1)

        # Test days = 365 (maximum)
        result2 = await server.expire_memories(days=365)
        assert_ascii_only(result2)

    @pytest.mark.asyncio
    async def test_get_memory_age_stats_happy_path(self, mock_global_instances):
        """Test get_memory_age_stats returns age distribution"""
        server = mock_global_instances

        # Create a proper async function that returns the dict
        async def mock_stats():
            return {
                "avg_age_days": 45.5,
                "median_age_days": 30,
                "oldest_memory_days": 180,
                "newest_memory_days": 1
            }

        server.memory_manager.get_memory_age_stats = mock_stats

        result = await server.get_memory_age_stats()

        assert_ascii_only(result)
        assert "45.5" in result or "average" in result.lower() or "age" in result.lower()

    @pytest.mark.asyncio
    async def test_set_memory_ttl_happy_path(self, mock_global_instances):
        """Test set_memory_ttl sets time-to-live"""
        server = mock_global_instances

        # Create a proper async function that returns the value
        async def mock_set_ttl(memory_id=None, ttl_days=None):
            return True

        server.memory_manager.set_ttl = mock_set_ttl

        result = await server.set_memory_ttl(memory_id="test-id", ttl_days=30)

        assert_ascii_only(result)
        assert "OK" in result or "set" in result.lower() or "ttl" in result.lower()

    @pytest.mark.asyncio
    async def test_set_memory_ttl_boundary_values(self, mock_global_instances):
        """Test set_memory_ttl with boundary TTL values"""
        server = mock_global_instances

        # Create a proper async function that returns the value
        async def mock_set_ttl(memory_id=None, ttl_days=None):
            return True

        server.memory_manager.set_ttl = mock_set_ttl

        # Test ttl_days = 1 (minimum)
        result1 = await server.set_memory_ttl(memory_id="test-id", ttl_days=1)
        assert_ascii_only(result1)

        # Test ttl_days = 365 (typical maximum)
        result2 = await server.set_memory_ttl(memory_id="test-id", ttl_days=365)
        assert_ascii_only(result2)

    @pytest.mark.asyncio
    async def test_archive_category_happy_path(self, mock_global_instances):
        """Test archive_category archives old memories"""
        server = mock_global_instances

        # Create a proper async function that returns the value
        async def mock_archive(category=None, days=None):
            return {
                "archived_count": 15,
                "category": "test"
            }

        server.memory_manager.archive_category = mock_archive

        result = await server.archive_category(category="test", days=180)

        assert_ascii_only(result)
        assert "15" in result or "archived" in result.lower() or "test" in result.lower()


# ============================================================================
# 4. Deduplication Tools (3 tools)
# ============================================================================

class TestDeduplicationTools:
    """Test memory deduplication tools"""

    @pytest.mark.asyncio
    async def test_check_duplicate_happy_path(self, mock_global_instances):
        """Test check_duplicate detects duplicates"""
        server = mock_global_instances

        server.memory_deduplicator.check_duplicate = AsyncMock(return_value={
            "is_duplicate": True,
            "duplicate_type": "exact",
            "reason": "Exact match found",
            "existing_id": "existing-123",
            "action": "skip"
        })

        result = await server.check_duplicate(
            content="Duplicate content",
            agent_id="test-agent"
        )

        assert_ascii_only(result)
        assert "duplicate" in result.lower()
        assert "existing-123" in result

    @pytest.mark.asyncio
    async def test_check_duplicate_not_duplicate(self, mock_global_instances):
        """Test check_duplicate when content is unique"""
        server = mock_global_instances

        server.memory_deduplicator.check_duplicate = AsyncMock(return_value={
            "is_duplicate": False,
            "confidence": 0.95
        })

        result = await server.check_duplicate(
            content="Unique content",
            agent_id="test-agent"
        )

        assert_ascii_only(result)
        assert "not duplicate" in result.lower() or "unique" in result.lower() or "no duplicate" in result.lower() or "safe to add" in result.lower()

    @pytest.mark.asyncio
    async def test_check_duplicate_empty_content(self, mock_global_instances):
        """Test check_duplicate with empty content"""
        server = mock_global_instances

        server.memory_deduplicator.check_duplicate = AsyncMock(return_value={
            "is_duplicate": False
        })

        result = await server.check_duplicate(content="", agent_id="test-agent")

        assert_ascii_only(result)

    @pytest.mark.asyncio
    async def test_auto_deduplicate_happy_path(self, mock_global_instances):
        """Test auto_deduplicate removes duplicates"""
        server = mock_global_instances

        async def mock_dedupe(agent_id=None):
            return {
                "status": "success",
                "results": {
                    "removed_count": 5,
                    "kept_count": 20
                }
            }

        server.memory_deduplicator.auto_deduplicate = mock_dedupe

        result = await server.auto_deduplicate(agent_id="test-agent")

        assert_ascii_only(result)
        assert "5" in result or "removed" in result.lower()

    @pytest.mark.asyncio
    async def test_auto_deduplicate_all_agents(self, mock_global_instances):
        """Test auto_deduplicate for all agents"""
        server = mock_global_instances

        async def mock_dedupe(agent_id=None):
            return {
                "status": "success",
                "results": {
                    "total_removed": 15,
                    "agents_processed": 3
                }
            }

        server.memory_deduplicator.auto_deduplicate = mock_dedupe

        result = await server.auto_deduplicate()

        assert_ascii_only(result)
        assert "15" in result or "removed" in result.lower()

    @pytest.mark.asyncio
    async def test_get_deduplication_stats_happy_path(self, mock_global_instances):
        """Test get_deduplication_stats returns statistics"""
        server = mock_global_instances

        # Create a proper async function that returns the dict
        async def mock_stats():
            return {
                "total_duplicates_found": 50,
                "total_duplicates_removed": 45,
                "deduplication_rate": 0.90
            }

        server.memory_deduplicator.get_stats = mock_stats

        result = await server.get_deduplication_stats()

        assert_ascii_only(result)
        assert "50" in result or "45" in result


# ============================================================================
# 5. Summarization Tools (3 tools)
# ============================================================================

class TestSummarizationTools:
    """Test memory summarization tools"""

    @pytest.mark.asyncio
    async def test_summarize_old_memories_happy_path(self, mock_global_instances):
        """Test summarize_old_memories creates summaries"""
        server = mock_global_instances

        # Create a proper async function that returns the dict
        async def mock_summarize(days=None, min_length=None, dry_run=None):
            return {
                "summaries_created": 3,
                "memories_summarized": 15,
                "total_compression_ratio": 0.65
            }

        server.memory_summarizer.summarize_old_memories = mock_summarize

        result = await server.summarize_old_memories(days=30, min_length=1000, dry_run=False)

        assert_ascii_only(result)
        assert "3" in result or "summary" in result.lower()

    @pytest.mark.asyncio
    async def test_summarize_old_memories_dry_run(self, mock_global_instances):
        """Test summarize_old_memories in dry-run mode"""
        server = mock_global_instances

        async def mock_summarize(days=None, min_length=None, dry_run=None):
            return {
                "summaries_created": 0,
                "would_summarize": 10
            }

        server.memory_summarizer.summarize_old_memories = mock_summarize

        result = await server.summarize_old_memories(days=30, dry_run=True)

        assert_ascii_only(result)
        assert "dry" in result.lower() or "would" in result.lower()

    @pytest.mark.asyncio
    async def test_summarize_category_happy_path(self, mock_global_instances):
        """Test summarize_category summarizes specific category"""
        server = mock_global_instances

        async def mock_summarize_cat(category=None, days=None):
            return {
                "category": "trading",
                "summaries_created": 2
            }

        server.memory_summarizer.summarize_category = mock_summarize_cat

        result = await server.summarize_category(category="trading", days=30)

        assert_ascii_only(result)
        assert "trading" in result.lower()

    @pytest.mark.asyncio
    async def test_get_summary_stats_happy_path(self, mock_global_instances):
        """Test get_summary_stats returns summarization statistics"""
        server = mock_global_instances

        # Create a proper async function that returns the dict
        async def mock_stats():
            return {
                "total_summaries": 100,
                "avg_compression_ratio": 0.7,
                "total_space_saved_bytes": 50000
            }

        server.memory_summarizer.get_stats = mock_stats

        result = await server.get_summary_stats()

        assert_ascii_only(result)
        assert "100" in result or "summary" in result.lower()


# ============================================================================
# 6. Performance Analytics Tools (3 tools)
# ============================================================================

class TestPerformanceAnalyticsTools:
    """Test performance monitoring and analytics tools"""

    @pytest.mark.asyncio
    async def test_get_performance_metrics_happy_path(self, mock_global_instances):
        """Test get_performance_metrics returns performance data"""
        server = mock_global_instances

        async def mock_get_performance_metrics():
            return {
                "timestamp": datetime.now(UTC).isoformat(),
                "query_performance": {
                    "avg_time_ms": 45.5,
                    "min_time_ms": 10.0,
                    "max_time_ms": 100.0,
                    "p50_time_ms": 40.0,
                    "p95_time_ms": 80.0,
                    "total_queries": 1000
                },
                "cache_performance": {
                    "hits": 800,
                    "misses": 200,
                    "hit_rate": 0.8
                }
            }

        server.performance_analytics.get_performance_metrics = mock_get_performance_metrics

        result = await server.get_performance_metrics()

        assert_ascii_only(result)
        assert "45.5" in result or "query" in result.lower()

    @pytest.mark.asyncio
    async def test_get_slow_queries_happy_path(self, mock_global_instances):
        """Test get_slow_queries returns slow queries"""
        server = mock_global_instances

        async def mock_get_slow_queries(threshold=None, limit=None):
            return [
                {"query": "SELECT * FROM memories", "duration_ms": 1500},
                {"query": "SELECT * FROM documents", "duration_ms": 1200}
            ]

        server.performance_analytics.get_slow_queries = mock_get_slow_queries

        result = await server.get_slow_queries(threshold_ms=1000, limit=10)

        assert_ascii_only(result)
        assert "1500" in result or "slow" in result.lower()

    @pytest.mark.asyncio
    async def test_get_slow_queries_custom_threshold(self, mock_global_instances):
        """Test get_slow_queries with custom threshold"""
        server = mock_global_instances

        async def mock_get_slow_queries(threshold=None, limit=None):
            return []

        server.performance_analytics.get_slow_queries = mock_get_slow_queries

        result = await server.get_slow_queries(threshold_ms=500, limit=20)

        assert_ascii_only(result)

    @pytest.mark.asyncio
    async def test_get_prometheus_metrics_happy_path(self, mock_global_instances):
        """Test get_prometheus_metrics returns Prometheus format"""
        server = mock_global_instances

        async def mock_get_prometheus_metrics():
            return {
            "metrics": [
                {"name": "cognee_query_count", "value": 1000},
                {"name": "cognee_memory_count", "value": 500}
            ]
        })

        result = await server.get_prometheus_metrics()

        assert_ascii_only(result)


# ============================================================================
# 7. Cross-Agent Sharing Tools (4 tools)
# ============================================================================

class TestCrossAgentSharingTools:
    """Test cross-agent memory sharing tools"""

    @pytest.mark.asyncio
    async def test_set_memory_sharing_happy_path(self, mock_global_instances):
        """Test set_memory_sharing configures sharing policy"""
        server = mock_global_instances

        async def mock_set_policy(memory_id=None, policy=None, allowed_agents=None):
            return {"success": True, "memory_id": "test-memory"}

        server.cross_agent_sharing.set_sharing_policy = mock_set_policy

        result = await server.set_memory_sharing(
            memory_id="test-memory",
            policy="shared",
            allowed_agents='["agent-1", "agent-2"]'
        )

        assert_ascii_only(result)
        assert "OK" in result or "set" in result.lower()

    @pytest.mark.asyncio
    async def test_set_memory_sharing_invalid_policy(self, mock_global_instances):
        """Test set_memory_sharing with invalid policy"""
        server = mock_global_instances

        result = await server.set_memory_sharing(
            memory_id="test-memory",
            policy="invalid_policy"
        )

        assert_ascii_only(result)
        assert "invalid" in result.lower() or "ERR" in result

    @pytest.mark.asyncio
    async def test_check_memory_access_happy_path(self, mock_global_instances):
        """Test check_memory_access verifies access permissions"""
        server = mock_global_instances

        async def mock_check_access(memory_id=None, agent_id=None):
            return {
                "has_access": True,
                "access_level": "read",
                "memory_id": "test-memory"
            }

        server.cross_agent_sharing.check_access = mock_check_access

        result = await server.check_memory_access(
            memory_id="test-memory",
            agent_id="agent-2"
        )

        assert_ascii_only(result)
        assert "true" in result.lower() or "has access" in result.lower()

    @pytest.mark.asyncio
    async def test_get_shared_memories_happy_path(self, mock_global_instances):
        """Test get_shared_memories returns shared memories"""
        server = mock_global_instances

        async def mock_get_shared(agent_id=None, limit=None):
            return [
                create_mock_memory("shared-1", "Shared memory 1"),
                create_mock_memory("shared-2", "Shared memory 2")
            ]

        server.cross_agent_sharing.get_shared_memories = mock_get_shared

        result = await server.get_shared_memories(agent_id="agent-2", limit=50)

        assert_ascii_only(result)
        assert "shared-1" in result or "Shared" in result

    @pytest.mark.asyncio
    async def test_create_shared_space_happy_path(self, mock_global_instances):
        """Test create_shared_space creates shared memory space"""
        server = mock_global_instances

        async def mock_create_space(space_name=None, member_agents=None):
            return {
                "space_name": "team-space",
                "members": ["agent-1", "agent-2"]
            }

        server.cross_agent_sharing.create_shared_space = mock_create_space

        result = await server.create_shared_space(
            space_name="team-space",
            member_agents='["agent-1", "agent-2"]'
        )

        assert_ascii_only(result)
        assert "team-space" in result.lower()


# ============================================================================
# 8. Real-Time Sync Tools (3 tools)
# ============================================================================

class TestRealTimeSyncTools:
    """Test real-time memory synchronization tools"""

    @pytest.mark.asyncio
    async def test_publish_memory_event_happy_path(self, mock_global_instances):
        """Test publish_memory_event publishes event"""
        server = mock_global_instances

        async def mock_publish(event_type=None, memory_id=None, agent_id=None, data=None):
            return True

        server.realtime_sync.publish_event = mock_publish

        result = await server.publish_memory_event(
            event_type="memory_created",
            memory_id="test-memory",
            agent_id="agent-1",
            data='{"priority": "high"}'
        )

        assert_ascii_only(result)
        assert "OK" in result or "published" in result.lower()

    @pytest.mark.asyncio
    async def test_publish_memory_event_invalid_json(self, mock_global_instances):
        """Test publish_memory_event with invalid JSON data"""
        server = mock_global_instances

        async def mock_publish(event_type=None, memory_id=None, agent_id=None, data=None):
            return True

        server.realtime_sync.publish_event = mock_publish

        # Should handle invalid JSON gracefully
        result = await server.publish_memory_event(
            event_type="memory_created",
            memory_id="test-memory",
            agent_id="agent-1",
            data="invalid json"
        )

        assert_ascii_only(result)

    @pytest.mark.asyncio
    async def test_get_sync_status_happy_path(self, mock_global_instances):
        """Test get_sync_status returns synchronization status"""
        server = mock_global_instances

        async def mock_get_status():
            return {
            "status": "synced",
            "last_sync": datetime.now(UTC).isoformat(),
            "pending_events": 0
        })

        result = await server.get_sync_status()

        assert_ascii_only(result)
        assert "synced" in result.lower() or "status" in result.lower()

    @pytest.mark.asyncio
    async def test_sync_agent_state_happy_path(self, mock_global_instances):
        """Test sync_agent_state synchronizes agents"""
        server = mock_global_instances

        async def mock_sync(source_agent=None, target_agent=None, category=None):
            return {
                "synced_count": 10,
                "source_agent": "agent-1",
                "target_agent": "agent-2"
            }

        server.realtime_sync.sync_agent_state = mock_sync

        result = await server.sync_agent_state(
            source_agent="agent-1",
            target_agent="agent-2",
            category="trading"
        )

        assert_ascii_only(result)
        assert "10" in result or "synced" in result.lower()


# ============================================================================
# 9. Backup & Recovery Tools (5 tools)
# ============================================================================

class TestBackupRecoveryTools:
    """Test backup and recovery tools"""

    @pytest.mark.asyncio
    async def test_create_backup_happy_path(self, mock_global_instances):
        """Test create_backup creates system backup"""
        server = mock_global_instances

        async def mock_create_backup(backup_type=None, description=None):
            return {
            "backup_id": "backup-123",
            "size_bytes": 1024000,
            "timestamp": datetime.now(UTC).isoformat()
        })

        result = await server.create_backup(
            backup_type="manual",
            description="Test backup"
        )

        assert_ascii_only(result)
        assert "backup-123" in result or "created" in result.lower()

    @pytest.mark.asyncio
    async def test_restore_backup_happy_path(self, mock_global_instances):
        """Test restore_backup restores from backup"""
        server = mock_global_instances

        async def mock_restore(backup_id=None, databases=None, validate=None):
            return {
                "restored_memories": 100,
                "backup_id": "backup-123"
            }

        server.recovery_manager.restore_backup = mock_restore

        result = await server.restore_backup(
            backup_id="backup-123",
            databases="all",
            validate=True
        )

        assert_ascii_only(result)
        assert "100" in result or "restored" in result.lower()

    @pytest.mark.asyncio
    async def test_list_backups_happy_path(self, mock_global_instances):
        """Test list_backups returns all backups"""
        server = mock_global_instances

        async def mock_list(limit=None):
            return [
                {
                    "backup_id": "backup-1",
                    "backup_type": "manual",
                    "timestamp": datetime.now(UTC).isoformat(),
                    "size_bytes": 1024000
                },
                {
                    "backup_id": "backup-2",
                    "backup_type": "daily",
                    "timestamp": datetime.now(UTC).isoformat(),
                    "size_bytes": 2048000
                }
            ]

        server.backup_manager.list_backups = mock_list

        result = await server.list_backups(limit=50)

        assert_ascii_only(result)
        assert "backup-1" in result or "backup-2" in result

    @pytest.mark.asyncio
    async def test_verify_backup_happy_path(self, mock_global_instances):
        """Test verify_backup verifies backup integrity"""
        server = mock_global_instances

        async def mock_verify(backup_id=None):
            return {
                "backup_id": "backup-123",
                "is_valid": True,
                "checksum": "abc123"
            }

        server.backup_manager.verify_backup = mock_verify

        result = await server.verify_backup(backup_id="backup-123")

        assert_ascii_only(result)
        assert "valid" in result.lower() or "OK" in result

    @pytest.mark.asyncio
    async def test_rollback_restore_happy_path(self, mock_global_instances):
        """Test rollback_restore rolls back restore operation"""
        server = mock_global_instances

        async def mock_rollback():
            return True

        server.recovery_manager.rollback = mock_rollback

        result = await server.rollback_restore()

        assert_ascii_only(result)
        assert "OK" in result or "rolled back" in result.lower()


# ============================================================================
# 10. Maintenance Tools (3 tools)
# ============================================================================

class TestMaintenanceTools:
    """Test maintenance and task scheduling tools"""

    @pytest.mark.asyncio
    async def test_schedule_task_happy_path(self, mock_global_instances):
        """Test schedule_task schedules maintenance task"""
        server = mock_global_instances

        async def mock_schedule(task_name=None, schedule=None, enabled=None):
            return {
            "task_id": "task-123",
            "task_name": "cleanup",
            "scheduled_time": datetime.now(UTC).isoformat()
        })

        result = await server.schedule_task(
            task_name="cleanup",
            schedule="0 2 * * *",  # Cron expression
            enabled=True
        )

        assert_ascii_only(result)
        assert "task-123" in result or "scheduled" in result.lower()

    @pytest.mark.asyncio
    async def test_list_tasks_happy_path(self, mock_global_instances):
        """Test list_tasks returns all scheduled tasks"""
        server = mock_global_instances

        async def mock_list():
            return [
                {
                    "task_id": "task-1",
                    "task_name": "cleanup",
                    "status": "scheduled"
                },
                {
                    "task_id": "task-2",
                    "task_name": "backup",
                    "status": "running"
                }
            ]

        server.maintenance_scheduler.list_tasks = mock_list

        result = await server.list_tasks()

        assert_ascii_only(result)
        assert "task-1" in result or "task-2" in result

    @pytest.mark.asyncio
    async def test_cancel_task_happy_path(self, mock_global_instances):
        """Test cancel_task cancels scheduled task"""
        server = mock_global_instances

        async def mock_cancel(task_id=None):
            returnTrue)

        result = await server.cancel_task(task_id="task-123")

        assert_ascii_only(result)
        assert "OK" in result or "cancelled" in result.lower()

    @pytest.mark.asyncio
    async def test_cancel_task_not_found(self, mock_global_instances):
        """Test cancel_task with non-existent task ID"""
        server = mock_global_instances

        async def mock_cancel(task_id=None):
            return False

        server.maintenance_scheduler.cancel_task = mock_cancel

        result = await server.cancel_task(task_id="non-existent-task")

        assert_ascii_only(result)
        assert "not found" in result.lower() or "ERR" in result


# ============================================================================
# 11. Multi-Language Support Tools (6 tools)
# ============================================================================

class TestMultiLanguageTools:
    """Test multi-language support tools"""

    @pytest.mark.asyncio
    async def test_detect_language_happy_path(self, mock_global_instances):
        """Test detect_language detects text language"""
        server = mock_global_instances

        server.language_detector_instance.detect_language = Mock(return_value=("en", 0.95))
        server.language_detector_instance.get_language_name = Mock(return_value="English")
        server.language_detector_instance.is_supported = Mock(return_value=True)

        result = await server.detect_language(text="This is English text")

        assert_ascii_only(result)
        assert "English" in result or "en" in result

    @pytest.mark.asyncio
    async def test_detect_language_multiple_languages(self, mock_global_instances):
        """Test detect_language with different languages"""
        server = mock_global_instances

        server.language_detector_instance.detect_language = Mock(return_value=("es", 0.92))
        server.language_detector_instance.get_language_name = Mock(return_value="Spanish")
        server.language_detector_instance.is_supported = Mock(return_value=True)

        result = await server.detect_language(text="Este es texto en espanol")

        assert_ascii_only(result)
        assert "Spanish" in result or "es" in result

    @pytest.mark.asyncio
    async def test_detect_language_empty_text(self, mock_global_instances):
        """Test detect_language with empty text"""
        server = mock_global_instances

        server.language_detector_instance.detect_language = Mock(side_effect=Exception("Empty text"))

        result = await server.detect_language(text="")

        assert_ascii_only(result)
        assert "ERR" in result or "error" in result.lower()

    @pytest.mark.asyncio
    async def test_get_supported_languages_happy_path(self, mock_global_instances):
        """Test get_supported_languages returns supported languages"""
        server = mock_global_instances

        def mock_get_languages():
            return [
                {"code": "en", "name": "English"},
                {"code": "es", "name": "Spanish"},
                {"code": "fr", "name": "French"}
            ]

        server.language_detector_instance.get_supported_languages = mock_get_languages

        result = await server.get_supported_languages()

        assert_ascii_only(result)
        assert "English" in result or "Spanish" in result or "French" in result

    @pytest.mark.asyncio
    async def test_search_by_language_happy_path(self, mock_global_instances):
        """Test search_by_language searches in specific language"""
        server = mock_global_instances

        async def mock_search(query=None, language=None, limit=None):
            return [
                create_mock_memory("mem-1", "Resultado en espaol"),
                create_mock_memory("mem-2", "Otro resultado")
            ]

        server.multi_language_search_instance.search_by_language = mock_search

        result = await server.search_by_language(
            query="prueba",
            language="es",
            limit=10
        )

        assert_ascii_only(result)
        assert "mem-1" in result or "resultado" in result.lower()

    @pytest.mark.asyncio
    async def test_get_language_distribution_happy_path(self, mock_global_instances):
        """Test get_language_distribution returns language stats"""
        server = mock_global_instances

        server.multi_language_search_instance.get_language_distribution = AsyncMock(
            return_value={
                "en": 0.60,
                "es": 0.25,
                "fr": 0.15
            }
        )

        result = await server.get_language_distribution()

        assert_ascii_only(result)
        assert "0.60" in result or "60" in result or "English" in result

    @pytest.mark.asyncio
    async def test_cross_language_search_happy_path(self, mock_global_instances):
        """Test cross_language_search searches across languages"""
        server = mock_global_instances

        async def mock_cross_search(query=None, source_language=None, target_languages=None, limit=None):
            return [
                create_mock_memory("mem-1", "English result"),
                create_mock_memory("mem-2", "Spanish translation")
            ]

        server.multi_language_search_instance.cross_language_search = mock_cross_search

        result = await server.cross_language_search(
            query="test",
            source_language="en",
            target_languages='["es", "fr"]',
            limit=10
        )

        assert_ascii_only(result)

    @pytest.mark.asyncio
    async def test_get_search_facets_happy_path(self, mock_global_instances):
        """Test get_search_facets returns search facets"""
        server = mock_global_instances

        server.advanced_search_engine.get_search_facets = AsyncMock(
            return_value={
                "categories": {"trading": 10, "development": 5},
                "languages": {"en": 8, "es": 7}
            }
        )

        result = await server.get_search_facets()

        assert_ascii_only(result)
        assert "trading" in result or "en" in result


# ============================================================================
# 12. Advanced AI Features Tools (7 tools)
# ============================================================================

class TestAdvancedAITools:
    """Test advanced AI-powered tools"""

    @pytest.mark.asyncio
    async def test_intelligent_summarize_happy_path(self, mock_global_instances):
        """Test intelligent_summarize creates AI-powered summary"""
        server = mock_global_instances

        async def mock_summarize(memory_id=None, strategy=None):
            return {
                "summary": "This is a concise summary of the content",
                "key_points": ["Point 1", "Point 2"],
                "compression_ratio": 0.7
            }

        server.intelligent_summarizer.summarize_memory = mock_summarize

        result = await server.intelligent_summarize(
            memory_id="test-memory-id",
            strategy="standard"
        )

        assert_ascii_only(result)
        assert "summary" in result.lower()

    @pytest.mark.asyncio
    async def test_intelligent_summarize_different_strategies(self, mock_global_instances):
        """Test intelligent_summarize with different strategies"""
        server = mock_global_instances

        async def mock_summarize(memory_id=None, strategy=None):
            return {
                "summary": "Summary text",
                "strategy": "extractive"
            }

        server.intelligent_summarizer.summarize_memory = mock_summarize

        # Test standard strategy
        result1 = await server.intelligent_summarize(
            memory_id="test-id",
            strategy="standard"
        )
        assert_ascii_only(result1)

        # Test detailed strategy
        result2 = await server.intelligent_summarize(
            memory_id="test-id",
            strategy="detailed"
        )
        assert_ascii_only(result2)

    @pytest.mark.asyncio
    async def test_auto_summarize_old_memories_happy_path(self, mock_global_instances):
        """Test auto_summarize_old_memories automatically summarizes"""
        server = mock_global_instances

        async def mock_auto_summarize(days_old=None, strategy=None):
            return {
                "summaries_created": 5,
                "memories_processed": 25
            }

        server.intelligent_summarizer.auto_summarize_old_memories = mock_auto_summarize

        result = await server.auto_summarize_old_memories(
            days_old=30,
            strategy="standard"
        )

        assert_ascii_only(result)
        assert "5" in result or "summary" in result.lower()

    @pytest.mark.asyncio
    async def test_cluster_memories_happy_path(self, mock_global_instances):
        """Test cluster_memories groups similar memories"""
        server = mock_global_instances

        async def mock_cluster(category=None, agent_id=None, limit=None):
            return {
            "clusters": [
                {"cluster_id": 1, "count": 10, "theme": "trading"},
                {"cluster_id": 2, "count": 8, "theme": "development"}
            ]
        })

        result = await server.cluster_memories(
            category="trading",
            agent_id="test-agent",
            limit=100
        )

        assert_ascii_only(result)
        assert "cluster" in result.lower()

    @pytest.mark.asyncio
    async def test_advanced_search_happy_path(self, mock_global_instances):
        """Test advanced_search with reranking"""
        server = mock_global_instances

        async def mock_adv_search(query=None, strategy=None, limit=None):
            return[
            create_mock_memory("mem-1", "High relevance result"),
            create_mock_memory("mem-2", "Medium relevance result")
        ])

        result = await server.advanced_search(
            query="test query",
            strategy="combined",
            limit=10
        )

        assert_ascii_only(result)
        assert "mem-1" in result or "result" in result.lower()

    @pytest.mark.asyncio
    async def test_advanced_search_different_strategies(self, mock_global_instances):
        """Test advanced_search with different reranking strategies"""
        server = mock_global_instances

        async def mock_adv_search(query=None, strategy=None, limit=None):
            return[])

        # Test relevance strategy
        result1 = await server.advanced_search(
            query="test",
            strategy="relevance"
        )
        assert_ascii_only(result1)

        # Test recency strategy
        result2 = await server.advanced_search(
            query="test",
            strategy="recency"
        )
        assert_ascii_only(result2)

    @pytest.mark.asyncio
    async def test_expand_search_query_happy_path(self, mock_global_instances):
        """Test expand_search_query expands query with synonyms"""
        server = mock_global_instances

        async def mock_expand(query=None, max_expansions=None):
            return {
                "original_query": "trading",
                "expanded_terms": ["trading", "investing", "stocks", "market"],
                "expanded_query": "trading OR investing OR stocks OR market"
            }

        server.advanced_search_engine.expand_query = mock_expand

        result = await server.expand_search_query(
            query="trading",
            max_expansions=5
        )

        assert_ascii_only(result)
        assert "trading" in result.lower()
        assert "investing" in result.lower()

    @pytest.mark.asyncio
    async def test_expand_search_query_boundary_values(self, mock_global_instances):
        """Test expand_search_query with expansion limits"""
        server = mock_global_instances

        async def mock_expand(query=None, max_expansions=None):
            return {
                "original_query": "test",
                "expanded_terms": ["test"]
            }

        server.advanced_search_engine.expand_query = mock_expand

        # Test max_expansions = 1
        result1 = await server.expand_search_query(query="test", max_expansions=1)
        assert_ascii_only(result1)

        # Test max_expansions = 20
        result2 = await server.expand_search_query(query="test", max_expansions=20)
        assert_ascii_only(result2)

    @pytest.mark.asyncio
    async def test_get_search_analytics_happy_path(self, mock_global_instances):
        """Test get_search_analytics returns search analytics"""
        server = mock_global_instances

        async def mock_get_analytics(days_back=None):
            return {
            "total_searches": 1000,
            "avg_results": 5.5,
            "top_queries": ["trading", "development", "test"]
        })

        result = await server.get_search_analytics(days_back=30)

        assert_ascii_only(result)
        assert "1000" in result or "search" in result.lower()

    @pytest.mark.asyncio
    async def test_get_summarization_stats_happy_path(self, mock_global_instances):
        """Test get_summarization_stats returns summarization analytics"""
        server = mock_global_instances

        server.intelligent_summarizer.get_stats = AsyncMock(
            return_value={
                "total_summaries": 150,
                "avg_compression_ratio": 0.68,
                "strategy_distribution": {
                    "abstractive": 80,
                    "extractive": 70
                }
            }
        )

        result = await server.get_summarization_stats()

        assert_ascii_only(result)
        assert "150" in result or "summary" in result.lower()


# ============================================================================
# 13. Additional Deduplication Tools
# ============================================================================

class TestAdditionalDeduplicationTools:
    """Test additional deduplication tools"""

    @pytest.mark.asyncio
    async def test_deduplicate_happy_path(self, mock_global_instances):
        """Test deduplicate performs deduplication"""
        server = mock_global_instances

        async def mock_deduplicate(agent_id=None):
            return {
                "removed_count": 10,
                "kept_count": 40
            }

        server.memory_deduplicator.deduplicate = mock_deduplicate

        result = await server.deduplicate(agent_id="test-agent")

        assert_ascii_only(result)
        assert "10" in result or "removed" in result.lower()

    @pytest.mark.asyncio
    async def test_schedule_deduplication_happy_path(self, mock_global_instances):
        """Test schedule_deduplication schedules auto-deduplication"""
        server = mock_global_instances

        async def mock_schedule_dedup(schedule=None):
            return {
            "schedule": "weekly",
            "next_run": datetime.now(UTC).isoformat()
        })

        result = await server.schedule_deduplication(schedule="weekly")

        assert_ascii_only(result)
        assert "weekly" in result.lower() or "scheduled" in result.lower()

    @pytest.mark.asyncio
    async def test_deduplication_report_happy_path(self, mock_global_instances):
        """Test deduplication_report generates report"""
        server = mock_global_instances

        server.memory_deduplicator.get_report = AsyncMock(
            return_value={
                "total_duplicates": 50,
                "resolved": 45,
                "pending": 5
            }
        )

        result = await server.deduplication_report()

        assert_ascii_only(result)
        assert "50" in result or "duplicate" in result.lower()


# ============================================================================
# 14. Additional Summarization Tools
# ============================================================================

class TestAdditionalSummarizationTools:
    """Test additional summarization tools"""

    @pytest.mark.asyncio
    async def test_schedule_summarization_happy_path(self, mock_global_instances):
        """Test schedule_summarization schedules auto-summarization"""
        server = mock_global_instances

        async def mock_schedule_summ(schedule=None):
            return {
            "schedule": "monthly",
            "next_run": datetime.now(UTC).isoformat()
        })

        result = await server.schedule_summarization(schedule="monthly")

        assert_ascii_only(result)
        assert "monthly" in result.lower() or "scheduled" in result.lower()

    @pytest.mark.asyncio
    async def test_summary_stats_happy_path(self, mock_global_instances):
        """Test summary_stats returns summary statistics"""
        server = mock_global_instances

        async def mock_summ_stats():
            return {
            "total_memories": 1000,
            "summarized_memories": 200,
            "full_memories": 800,
            "summarization_ratio": 0.2,
            "estimated_space_saved_mb": 50.0
        })

        result = await server.summary_stats()

        assert_ascii_only(result)
        assert "1000" in result or "summary" in result.lower() or "200" in result


# ============================================================================
# Integration Tests - Database Interactions
# ============================================================================

class TestDatabaseIntegration:
    """Test database integration for all tools"""

    @pytest.mark.asyncio
    async def test_postgres_integration_add_and_search(self, mock_global_instances, mock_postgres_conn):
        """Test PostgreSQL integration: add memory then search"""
        server = mock_global_instances

        # Add memory
        mock_postgres_conn.fetchval = AsyncMock(return_value="mem-123")
        server.postgres_pool.acquire = Mock(return_value=create_mock_acquire_context(mock_postgres_conn))
        server.memory_deduplicator.check_duplicate = AsyncMock(return_value={"is_duplicate": False})

        add_result = await server.add_memory(content="Integration test memory")
        assert "OK" in add_result or "mem-123" in add_result

        # Search memory
        mock_memories = [create_mock_memory("mem-123", "Integration test memory")]
        mock_postgres_conn.fetch = AsyncMock(return_value=mock_memories)

        search_result = await server.search_memories(query="integration test")
        assert_ascii_only(search_result)

    @pytest.mark.asyncio
    async def test_qdrant_integration_semantic_search(self, mock_global_instances):
        """Test Qdrant integration for semantic search"""
        server = mock_global_instances

        # Mock Qdrant search to return actual data, not a coroutine
        async def mock_search(*args, **kwargs):
            return [
                {"id": "mem-1", "score": 0.95, "payload": {"content": "Semantic result"}}
            ]

        server.qdrant_client.search = mock_search

        result = await server.search(query="semantic search", limit=10)

        assert_ascii_only(result)
        assert "0.95" in result or "semantic" in result.lower()

    @pytest.mark.asyncio
    async def test_redis_integration_caching(self, mock_global_instances):
        """Test Redis integration for caching"""
        server = mock_global_instances

        server.redis_client.get = AsyncMock(return_value='{"cached": "data"}')
        server.redis_client.set = AsyncMock(return_value=True)

        # Cache get
        server.redis_client.get = AsyncMock(return_value=None)  # Cache miss

        result = await server.get_sync_status()
        assert_ascii_only(result)


# ============================================================================
# Error Handling Tests
# ============================================================================

class TestErrorHandling:
    """Test error handling across all tools"""

    @pytest.mark.asyncio
    async def test_tool_handles_database_connection_error(self, mock_global_instances):
        """Test tools handle database connection errors gracefully"""
        server = mock_global_instances

        # Mock connection error
        mock_postgres_conn = AsyncMock()
        mock_postgres_conn.fetch = AsyncMock(side_effect=Exception("Connection lost"))
        server.postgres_pool.acquire = Mock(return_value=create_mock_acquire_context(mock_postgres_conn))

        result = await server.search_memories(query="test")

        assert_ascii_only(result)
        # Should handle error gracefully, not crash

    @pytest.mark.asyncio
    async def test_tool_handles_timeout(self, mock_global_instances, mock_postgres_conn):
        """Test tools handle timeout errors"""
        server = mock_global_instances

        # Mock timeout
        mock_postgres_conn.fetch = AsyncMock(side_effect=asyncio.TimeoutError("Query timeout"))
        server.postgres_pool.acquire = Mock(return_value=create_mock_acquire_context(mock_postgres_conn))

        result = await server.get_memories()

        assert_ascii_only(result)

    @pytest.mark.asyncio
    async def test_tool_handles_invalid_json(self, mock_global_instances):
        """Test tools handle invalid JSON in parameters"""
        server = mock_global_instances

        result = await server.set_memory_sharing(
            memory_id="test-id",
            policy="read",
            allowed_agents="invalid json"
        )

        assert_ascii_only(result)
        # Should handle gracefully


# ============================================================================
# ASCII Output Validation Tests
# ============================================================================

class TestASCIIOutput:
    """Ensure all tool output is ASCII-only (no Unicode)"""

    @pytest.mark.asyncio
    async def test_all_tools_ascii_output(self, mock_global_instances):
        """Test all tools produce ASCII-only output"""
        server = mock_global_instances

        # Mock all dependencies
        mock_postgres_conn = AsyncMock()
        mock_postgres_conn.fetch = AsyncMock(return_value=[])
        mock_postgres_conn.fetchrow = AsyncMock(return_value=None)
        mock_postgres_conn.fetchval = AsyncMock(return_value=1)
        mock_postgres_conn.execute = AsyncMock(return_value=None)
        server.postgres_pool.acquire = Mock(return_value=create_mock_acquire_context(mock_postgres_conn))

        server.memory_deduplicator.check_duplicate = AsyncMock(return_value={"is_duplicate": False, "confidence": 0.95})
        server.memory_manager.add_memory = AsyncMock(return_value="test-id")
        server.qdrant_client.search = Mock(return_value=[])
        server.language_detector_instance.detect_language = Mock(return_value=("en", 0.95))
        server.language_detector_instance.get_language_name = Mock(return_value="English")
        server.language_detector_instance.is_supported = Mock(return_value=True)
        server.memory_manager.expire_old_memories = AsyncMock(return_value={"expired_count": 0, "freed_space_bytes": 0})
        server.memory_deduplicator.auto_deduplicate_agent = AsyncMock(return_value={"removed_count": 0, "kept_count": 0})
        server.memory_deduplicator.auto_deduplicate_all = AsyncMock(return_value={"total_removed": 0, "agents_processed": 0})
        server.memory_summarizer.summarize_old_memories = AsyncMock(return_value={"summaries_created": 0, "memories_summarized": 0})
        server.performance_analytics.get_metrics = AsyncMock(return_value={})
        async def mock_get_slow_queries(threshold=None, limit=None):
            return[])
        async def mock_get_prometheus_metrics():
            return {"metrics": []})
        async def mock_set_policy(memory_id=None, policy=None, allowed_agents=None):
            return {"success": True})
        async def mock_check_access(memory_id=None, agent_id=None):
            return {"has_access": False, "access_level": "none"})
        async def mock_get_shared(agent_id=None, limit=None):
            return[])
        async def mock_create_space(space_name=None, member_agents=None):
            return {"space_name": "test", "members": []})
        async def mock_publish(event_type=None, memory_id=None, agent_id=None, data=None):
            returnTrue)
        async def mock_get_status():
            return {"status": "ok", "pending_events": 0})
        async def mock_sync(source_agent=None, target_agent=None, category=None):
            return {"synced_count": 0})
        async def mock_create_backup(backup_type=None, description=None):
            return {"backup_id": "test", "timestamp": datetime.now(UTC).isoformat()})
        async def mock_restore(backup_id=None, databases=None, validate=None):
            return {"restored_memories": 0, "backup_id": "test"})
        async def mock_list(limit=None):
            return[])
        async def mock_verify(backup_id=None):
            return {"is_valid": True, "backup_id": "test"})
        async def mock_rollback():
            returnTrue)
        async def mock_schedule(task_name=None, schedule=None, enabled=None):
            return {"task_id": "test", "task_name": "test"})
        async def mock_list():
            return[])
        async def mock_cancel(task_id=None):
            returnFalse)
        async def mock_search_lang(query=None, language=None, limit=None):
            return[])
        async def mock_get_distribution():
            return {"en": 1.0})
        async def mock_cross_search(query=None, source_language=None, target_languages=None, limit=None):
            return[])
        async def mock_get_facets():
            return {"categories": {}, "languages": {}})
        async def mock_summarize_mem(memory_id=None, strategy=None):
            return {"summary": "test summary", "compression_ratio": 0.5})
        async def mock_auto_summarize(days_old=None, strategy=None):
            return {"summaries_created": 0, "memories_processed": 0})
        async def mock_cluster(category=None, agent_id=None, limit=None):
            return {"clusters": []})
        async def mock_adv_search(query=None, strategy=None, limit=None):
            return[])
        async def mock_expand(query=None, max_expansions=None):
            return {"expanded_terms": [], "expanded_query": "test"})
        async def mock_get_analytics(days_back=None):
            return {"total_searches": 0})
        async def mock_get_summarizer_stats():
            return {"total_summaries": 0})
        server.language_detector_instance.get_supported_languages = Mock(return_value=[])
        async def mock_deduplicate(agent_id=None):
            return {"removed_count": 0, "kept_count": 0})
        async def mock_schedule_dedup(schedule=None):
            return {"schedule": "weekly"})
        async def mock_get_report():
            return {"total_duplicates": 0})
        async def mock_schedule_summ(schedule=None):
            return {"schedule": "monthly"})
        async def mock_summ_stats():
            return {
            "total_memories": 1000,
            "summarized_memories": 200,
            "full_memories": 800,
            "summarization_ratio": 0.2,
            "estimated_space_saved_mb": 50.0
        })

        # Test sample of critical tools
        tools_to_test = [
            ("add_memory", lambda: server.add_memory(content="test")),
            ("search_memories", lambda: server.search_memories(query="test")),
            ("get_memories", lambda: server.get_memories()),
            ("cognify", lambda: server.cognify(data="test")),
            ("health", lambda: server.health()),
            ("check_duplicate", lambda: server.check_duplicate(content="test")),
            ("detect_language", lambda: server.detect_language(text="test")),
            ("get_stats", lambda: server.get_stats()),
        ]

        for tool_name, tool_func in tools_to_test:
            result = await tool_func()
            assert_ascii_only(result, f"{tool_name} output")
            assert result is not None, f"{tool_name} returned None"


# ============================================================================
# Test Coverage Summary
# ============================================================================

"""
Coverage Summary for test_all_mcp_tools.py:

Tools Tested: 60+
Test Categories:
1. Standard Memory Tools (7): add_memory, search_memories, get_memories, get_memory, update_memory, delete_memory, list_agents
2. Enhanced Cognee Tools (5): cognify, search, list_data, get_stats, health
3. Memory Management (4): expire_memories, get_memory_age_stats, set_memory_ttl, archive_category
4. Deduplication (6): check_duplicate, auto_deduplicate, get_deduplication_stats, deduplicate, schedule_deduplication, deduplication_report
5. Summarization (5): summarize_old_memories, summarize_category, get_summary_stats, schedule_summarization, summary_stats
6. Performance (3): get_performance_metrics, get_slow_queries, get_prometheus_metrics
7. Cross-Agent Sharing (4): set_memory_sharing, check_memory_access, get_shared_memories, create_shared_space
8. Real-Time Sync (3): publish_memory_event, get_sync_status, sync_agent_state
9. Backup & Recovery (5): create_backup, restore_backup, list_backups, verify_backup, rollback_restore
10. Maintenance (3): schedule_task, list_tasks, cancel_task
11. Multi-Language (6): detect_language, get_supported_languages, search_by_language, get_language_distribution, cross_language_search, get_search_facets
12. Advanced AI (7): intelligent_summarize, auto_summarize_old_memories, cluster_memories, advanced_search, expand_search_query, get_search_analytics, get_summarization_stats

Test Scenarios:
- Happy path: Normal operation with valid inputs
- Edge cases: Boundary values, empty inputs, special characters
- Error cases: Missing parameters, invalid data types, connection errors
- Integration: Database interactions (PostgreSQL, Qdrant, Redis)
- ASCII output: All output validated for ASCII-only (no Unicode)

Total Test Count: 150+ individual test cases
"""
