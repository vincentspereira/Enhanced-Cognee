"""
Security Tests for Enhanced Cognee System

Comprehensive security testing including vulnerability assessment,
penetration testing, authentication/authorization validation, and data privacy compliance.
"""

import pytest
import asyncio
import json
import time
import requests
import subprocess
import tempfile
import os
from datetime import datetime, timezone
from unittest.mock import Mock, AsyncMock, patch
from typing import Dict, List, Any, Optional
import re
import base64
import hashlib
import secrets

# Mark all tests as security tests
pytestmark = [pytest.mark.security, pytest.mark.slow, pytest.mark.requires_docker]


class TestAuthenticationSecurity:
    """Test authentication and authorization security"""

    @pytest.fixture
    def api_base_url(self):
        """Base URL for Enhanced Cognee API"""
        return "http://localhost:28080"

    @pytest.fixture
    def security_test_data(self):
        """Security test data including malicious inputs"""
        return {
            "sql_injection_attempts": [
                "'; DROP TABLE users; --",
                "' OR '1'='1",
                "admin'--",
                "' UNION SELECT * FROM users --"
            ],
            "xss_attempts": [
                "<script>alert('XSS')</script>",
                "javascript:alert('XSS')",
                "<img src=x onerror=alert('XSS')>",
                "';alert('XSS');//"
            ],
            "path_traversal_attempts": [
                "../../../etc/passwd",
                "..\\..\\..\\windows\\system32\\config\\system",
                "....//....//....//etc/passwd"
            ],
            "command_injection_attempts": [
                "; ls -la",
                "| whoami",
                "&& cat /etc/passwd"
            ]
        }

    def test_sql_injection_prevention(self, api_base_url, security_test_data):
        """Test SQL injection prevention in login endpoint"""

        for injection_attempt in security_test_data["sql_injection_attempts"]:
            # Test login endpoint with SQL injection attempts
            login_data = {
                "username": injection_attempt,
                "password": "password123"
            }

            response = requests.post(
                f"{api_base_url}/api/v1/auth/login",
                json=login_data,
                timeout=30
            )

            # Should not succeed with SQL injection
            if response.status_code == 200:
                result = response.json()
                # If login succeeds, ensure it's legitimate, not due to SQL injection
                assert "token" not in result or result.get("username") != "admin"
            else:
                # Expected behavior - login should fail
                assert response.status_code in [400, 401, 403]

    def test_xss_prevention_in_user_input(self, api_base_url, security_test_data):
        """Test XSS prevention in user input fields"""

        # Test memory creation with XSS attempts
        for xss_attempt in security_test_data["xss_attempts"]:
            memory_data = {
                "content": xss_attempt,
                "agent_id": "test_agent",
                "memory_type": "episodic",
                "metadata": {"test_field": xss_attempt}
            }

            response = requests.post(
                f"{api_base_url}/api/v1/memory",
                json=memory_data,
                timeout=30
            )

            if response.status_code == 201:
                memory_result = response.json()

                # Ensure XSS is sanitized or encoded
                content = memory_result.get("content", "")
                assert "<script>" not in content.lower()
                assert "javascript:" not in content.lower()

                # Check metadata fields
                metadata = memory_result.get("metadata", {})
                test_field = metadata.get("test_field", "")
                assert "<script>" not in test_field.lower()
                assert "javascript:" not in test_field.lower()

    def test_authorization_bypass_prevention(self, api_base_url):
        """Test authorization bypass prevention"""

        # Test accessing protected endpoints without authentication
        protected_endpoints = [
            "/api/v1/user/profile",
            "/api/v1/memory",
            "/api/v1/trading/initialize",
            "/api/v1/coordination/session"
        ]

        for endpoint in protected_endpoints:
            response = requests.get(f"{api_base_url}{endpoint}", timeout=30)

            # Should require authentication
            assert response.status_code in [401, 403]

        # Test with invalid/expired tokens
        invalid_tokens = [
            "invalid.token.format",
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.invalid",
            "Bearer malformed_token",
            "Bearer "
        ]

        for invalid_token in invalid_tokens:
            headers = {"Authorization": invalid_token}
            response = requests.get(
                f"{api_base_url}/api/v1/user/profile",
                headers=headers,
                timeout=30
            )

            assert response.status_code in [401, 403]

    def test_password_security_requirements(self, api_base_url):
        """Test password security requirements"""

        # Test weak passwords
        weak_passwords = [
            "123456",
            "password",
            "admin",
            "123",
            "",
            "aaaaaa",
            "password123"
        ]

        for weak_password in weak_passwords:
            user_data = {
                "username": f"testuser_{hash(weak_password)}",
                "email": f"test_{hash(weak_password)}@example.com",
                "password": weak_password
            }

            response = requests.post(
                f"{api_base_url}/api/v1/auth/register",
                json=user_data,
                timeout=30
            )

            # Weak passwords should be rejected
            assert response.status_code in [400, 422]

        # Test strong password acceptance
        strong_password = "Str0ngP@ssw0rd!123"
        user_data = {
            "username": f"strong_user_{int(time.time())}",
            "email": f"strong_user_{int(time.time())}@example.com",
            "password": strong_password
        }

        response = requests.post(
            f"{api_base_url}/api/v1/auth/register",
            json=user_data,
            timeout=30
        )

        # Strong password should be accepted (or user already exists)
        assert response.status_code in [201, 409]

    def test_rate_limiting_enforcement(self, api_base_url):
        """Test rate limiting enforcement on sensitive endpoints"""

        # Test login rate limiting
        login_data = {
            "username": "rate_limit_test_user",
            "password": "password123"
        }

        rapid_requests = []
        start_time = time.time()

        # Make rapid requests
        for i in range(20):
            response = requests.post(
                f"{api_base_url}/api/v1/auth/login",
                json=login_data,
                timeout=5
            )
            rapid_requests.append((response.status_code, time.time() - start_time))

        # Check if rate limiting is enforced
        status_codes = [req[0] for req in rapid_requests]
        rate_limited_responses = sum(1 for code in status_codes if code == 429)

        # At least some requests should be rate limited after a threshold
        assert rate_limited_responses > 0 or len([c for c in status_codes if c == 401]) > 10

    def test_session_security(self, api_base_url):
        """Test session security and management"""

        # Create valid session
        user_data = {
            "username": f"session_test_user_{int(time.time())}",
            "email": f"session_test_{int(time.time())}@example.com",
            "password": "SecureSessionPassword123!"
        }

        # Register user
        requests.post(f"{api_base_url}/api/v1/auth/register", json=user_data, timeout=30)

        # Login to get session
        login_response = requests.post(
            f"{api_base_url}/api/v1/auth/login",
            json={"username": user_data["username"], "password": user_data["password"]},
            timeout=30
        )

        if login_response.status_code == 200:
            token = login_response.json()["token"]

            # Test token format and security
            assert "." in token  # JWT should have dots

            try:
                # Decode JWT header and payload (without verification)
                header_b64, payload_b64 = token.split(".")[:2]

                # Fix padding if needed
                header_b64 += "=" * (-len(header_b64) % 4)
                payload_b64 += "=" * (-len(payload_b64) % 4)

                header = base64.urlsafe_b64decode(header_b64)
                payload = base64.urlsafe_b64decode(payload_b64)

                header_data = json.loads(header)
                payload_data = json.loads(payload)

                # Check JWT structure
                assert "alg" in header_data
                assert "typ" in header_data
                assert "sub" in payload_data
                assert "exp" in payload_data

                # Check expiration
                exp_time = payload_data["exp"]
                current_time = int(time.time())
                assert exp_time > current_time
                assert exp_time <= current_time + 86400  # Should not be more than 24h

            except Exception as e:
                pytest.fail(f"Token validation failed: {e}")


class TestDataPrivacyAndCompliance:
    """Test data privacy and regulatory compliance"""

    @pytest.fixture
    def api_base_url(self):
        """Base URL for Enhanced Cognee API"""
        return "http://localhost:28080"

    @pytest.fixture
    def sensitive_data(self):
        """Sensitive test data for privacy testing"""
        return {
            "pii": {
                "ssn": "123-45-6789",
                "credit_card": "4532-1234-5678-9012",
                "email": "user@example.com",
                "phone": "+1-555-123-4567"
            },
            "personal_info": {
                "full_name": "John Doe",
                "address": "123 Main St, Anytown, USA",
                "date_of_birth": "1980-01-01",
                "medical_info": "Patient has hypertension"
            },
            "financial_info": {
                "account_number": "123456789",
                "routing_number": "987654321",
                "balance": 50000.00,
                "transaction_history": ["deposit 1000", "withdrawal 500"]
            }
        }

    def test_personal_data_anonymization(self, api_base_url, sensitive_data):
        """Test personal data anonymization in storage and retrieval"""

        # Store memory with sensitive data
        memory_data = {
            "content": f"User {sensitive_data['pii']['full_name']} with email {sensitive_data['pii']['email']} has account {sensitive_data['financial_info']['account_number']}",
            "agent_id": "privacy_test_agent",
            "memory_type": "episodic",
            "metadata": {
                "user_id": sensitive_data["pii"]["ssn"],
                "contact_email": sensitive_data["pii"]["email"],
                "phone": sensitive_data["pii"]["phone"],
                "address": sensitive_data["personal_info"]["address"]
            }
        }

        create_response = requests.post(
            f"{api_base_url}/api/v1/memory",
            json=memory_data,
            timeout=30
        )

        if create_response.status_code == 201:
            memory_id = create_response.json()["memory_id"]

            # Retrieve memory and check anonymization
            retrieve_response = requests.get(
                f"{api_base_url}/api/v1/memory/{memory_id}",
                timeout=30
            )

            if retrieve_response.status_code == 200:
                retrieved_memory = retrieve_response.json()
                content = retrieved_memory["content"]
                metadata = retrieved_memory["metadata"]

                # Check PII is anonymized or redacted
                assert sensitive_data["pii"]["ssn"] not in content
                assert sensitive_data["pii"]["email"] not in content
                assert sensitive_data["financial_info"]["account_number"] not in content
                assert sensitive_data["pii"]["ssn"] not in str(metadata)
                assert sensitive_data["pii"]["email"] not in str(metadata)

                # Check for partial or masked representations
                assert "***" in content or "xxx" in content or "###" in content

    def test_gdpr_compliance_data_portability(self, api_base_url, sensitive_data):
        """Test GDPR data portability requirements"""

        # Create user with personal data
        user_data = {
            "username": f"gdpr_user_{int(time.time())}",
            "email": sensitive_data["pii"]["email"],
            "full_name": sensitive_data["personal_info"]["full_name"],
            "phone": sensitive_data["pii"]["phone"],
            "address": sensitive_data["personal_info"]["address"],
            "password": "SecureGDPRPassword123!"
        }

        # Register user
        register_response = requests.post(
            f"{api_base_url}/api/v1/auth/register",
            json=user_data,
            timeout=30
        )

        if register_response.status_code in [201, 409]:  # 409 if user exists
            # Request data export (GDPR right to data portability)
            export_request = {
                "user_identifier": user_data["username"],
                "format": "json",
                "include_personal_data": True,
                "include_memories": True,
                "include_sessions": True
            }

            export_response = requests.post(
                f"{api_base_url}/api/v1/privacy/data-export",
                json=export_request,
                timeout=60
            )

            if export_response.status_code == 200:
                export_data = export_response.json()

                # Verify export contains required data
                assert "personal_data" in export_data
                assert "export_timestamp" in export_data
                assert "data_format" in export_data

                # Verify personal data completeness
                personal_data = export_data["personal_data"]
                assert "full_name" in personal_data
                assert "email" in personal_data
                assert "export_id" in export_data

    def test_gdpr_right_to_be_forgotten(self, api_base_url, sensitive_data):
        """Test GDPR right to erasure (right to be forgotten)"""

        # Create user and associated data
        username = f"erase_test_user_{int(time.time())}"
        user_data = {
            "username": username,
            "email": f"{username}@example.com",
            "password": "SecureErasePassword123!"
        }

        # Register user
        requests.post(f"{api_base_url}/api/v1/auth/register", json=user_data, timeout=30)

        # Create memories associated with user
        memory_ids = []
        for i in range(3):
            memory_data = {
                "content": f"Memory {i} for user {username} with personal info",
                "agent_id": "test_agent",
                "memory_type": "episodic",
                "metadata": {"user_id": username, "personal": True}
            }

            response = requests.post(f"{api_base_url}/api/v1/memory", json=memory_data, timeout=30)
            if response.status_code == 201:
                memory_ids.append(response.json()["memory_id"])

        # Request data erasure
        erasure_request = {
            "user_identifier": username,
            "erase_type": "full",  # Full erasure
            "confirmation": True,
            "reason": "GDPR Article 17 - Right to erasure"
        }

        erasure_response = requests.post(
            f"{api_base_url}/api/v1/privacy/data-erasure",
            json=erasure_request,
            timeout=60
        )

        if erasure_response.status_code == 200:
            erasure_result = erasure_response.json()

            # Verify erasure was completed
            assert erasure_result["status"] == "completed"
            assert "erased_items" in erasure_result
            assert "erasure_timestamp" in erasure_result

            # Verify data is no longer accessible
            # Test user account deletion
            login_response = requests.post(
                f"{api_base_url}/api/v1/auth/login",
                json={"username": username, "password": user_data["password"]},
                timeout=30
            )
            assert login_response.status_code in [401, 404]

            # Test memories are anonymized or deleted
            for memory_id in memory_ids:
                retrieve_response = requests.get(f"{api_base_url}/api/v1/memory/{memory_id}", timeout=30)
                if retrieve_response.status_code == 200:
                    memory = retrieve_response.json()
                    # User reference should be removed or anonymized
                    assert username not in str(memory.get("metadata", {}))

    def test_data_minimization_principle(self, api_base_url, sensitive_data):
        """Test data minimization principle - only collect necessary data"""

        # Test excessive data collection rejection
        excessive_data = {
            "username": f"excessive_user_{int(time.time())}",
            "email": "excessive@example.com",
            "password": "SecurePassword123!",
            "unnecessary_field_1": "extra data 1",
            "unnecessary_field_2": "extra data 2",
            "sensitive_field_1": sensitive_data["pii"]["ssn"],
            "sensitive_field_2": sensitive_data["pii"]["credit_card"],
            "biometric_data": "fingerprint_data_12345",
            "medical_history": sensitive_data["personal_info"]["medical_info"],
            "political_views": "liberal",
            "religious_beliefs": "atheist"
        }

        # This should be rejected due to excessive data collection
        response = requests.post(
            f"{api_base_url}/api/v1/auth/register",
            json=excessive_data,
            timeout=30
        )

        # System should reject excessive data collection
        assert response.status_code in [400, 422]

    def test_encryption_at_rest(self, api_base_url):
        """Test that sensitive data is encrypted at rest"""

        # This is a simplified test - in practice, you would check
        # database storage directly for encryption

        # Create memory with sensitive data
        sensitive_memory = {
            "content": "This contains sensitive financial information: account 123456789",
            "agent_id": "encryption_test_agent",
            "memory_type": "factual",
            "metadata": {
                "sensitive_data": "confidential",
                "encryption_required": True
            }
        }

        create_response = requests.post(
            f"{api_base_url}/api/v1/memory",
            json=sensitive_memory,
            timeout=30
        )

        if create_response.status_code == 201:
            memory_id = create_response.json()["memory_id"]

            # In a real implementation, you would:
            # 1. Check database storage for encrypted data
            # 2. Verify unencrypted sensitive data is not stored
            # 3. Check encryption keys are properly managed

            # For this test, we'll verify that the API handles encryption properly
            retrieve_response = requests.get(
                f"{api_base_url}/api/v1/memory/{memory_id}",
                timeout=30
            )

            if retrieve_response.status_code == 200:
                memory = retrieve_response.json()
                # API should handle encryption transparently
                assert memory["content"] == sensitive_memory["content"]
                assert "encrypted" in memory.get("metadata", {}) or \
                       memory.get("metadata", {}).get("encryption_status") == "encrypted"


class TestInfrastructureSecurity:
    """Test infrastructure and system security"""

    @pytest.fixture
    def api_base_url(self):
        """Base URL for Enhanced Cognee API"""
        return "http://localhost:28080"

    def test_api_security_headers(self, api_base_url):
        """Test security headers in API responses"""

        endpoints_to_test = [
            "/",
            "/health",
            "/api/v1/auth/login",
            "/api/v1/memory"
        ]

        security_headers_expected = [
            "X-Content-Type-Options",
            "X-Frame-Options",
            "X-XSS-Protection",
            "Strict-Transport-Security",
            "Content-Security-Policy"
        ]

        for endpoint in endpoints_to_test:
            response = requests.get(f"{api_base_url}{endpoint}", timeout=30)

            if response.status_code == 200:
                headers = response.headers

                # Check for important security headers
                for header in security_headers_expected:
                    # Some headers may not be present but should be configured
                    # This is a basic check - in production, all should be present
                    header_variants = [
                        header.lower(),
                        header.replace("-", "_").lower()
                    ]

                    found = any(key in headers.keys().lower() for key in header_variants)

                    if not found and header in ["X-Content-Type-Options", "X-Frame-Options"]:
                        # These should definitely be present
                        pytest.warn(f"Security header {header} not found in {endpoint}")

    def test_https_redirect(self, api_base_url):
        """Test HTTP to HTTPS redirect (if applicable)"""

        # This test would require HTTP endpoint configuration
        # For now, we'll verify the API handles requests properly
        try:
            # Try to access via HTTP (should redirect or reject)
            http_url = api_base_url.replace("http://", "http://")  # Keep as is for this test
            response = requests.get(http_url, timeout=10, allow_redirects=False)

            # Check for redirect to HTTPS (status 301/302) or proper handling
            if response.status_code in [301, 302]:
                location = response.headers.get("Location", "")
                assert location.startswith("https://")
            elif response.status_code != 200:
                # HTTP should be properly handled (rejected or redirected)
                pass

        except requests.exceptions.ConnectionError:
            # Expected if HTTP is not configured
            pass

    def test_cors_configuration(self, api_base_url):
        """Test CORS configuration"""

        # Test preflight request
        preflight_headers = {
            "Origin": "https://example.com",
            "Access-Control-Request-Method": "POST",
            "Access-Control-Request-Headers": "Content-Type"
        }

        response = requests.options(
            f"{api_base_url}/api/v1/memory",
            headers=preflight_headers,
            timeout=30
        )

        if response.status_code == 200:
            cors_headers = response.headers

            # Check CORS headers
            if "Access-Control-Allow-Origin" in cors_headers:
                # Should either be specific or properly configured
                allowed_origin = cors_headers["Access-Control-Allow-Origin"]
                assert allowed_origin in ["https://example.com", "*"]

            if "Access-Control-Allow-Methods" in cors_headers:
                allowed_methods = cors_headers["Access-Control-Allow-Methods"]
                assert "POST" in allowed_methods

    def test_error_information_disclosure(self, api_base_url):
        """Test that error responses don't disclose sensitive information"""

        # Test various error conditions
        error_endpoints = [
            "/api/v1/memory/999999",  # Non-existent memory
            "/api/v1/user/invalid-user",  # Non-existent user
            "/api/v1/nonexistent-endpoint"  # Invalid endpoint
        ]

        for endpoint in error_endpoints:
            response = requests.get(f"{api_base_url}{endpoint}", timeout=30)

            if response.status_code >= 400:
                error_response = response.text

                # Check for sensitive information in error messages
                sensitive_patterns = [
                    r'password',
                    r'secret',
                    r'key',
                    r'token',
                    r'database',
                    r'internal',
                    r'server',
                    r'error.*sql',
                    r'exception.*traceback'
                ]

                error_lower = error_response.lower()
                for pattern in sensitive_patterns:
                    matches = re.findall(pattern, error_lower)
                    if matches:
                        pytest.warn(f"Potential information disclosure in error: {matches}")

                # Check for stack traces or detailed error information
                if "traceback" in error_lower or "stack trace" in error_lower:
                    pytest.fail("Stack trace found in error response")

    def test_file_upload_security(self, api_base_url):
        """Test file upload security and validation"""

        # Create malicious file content
        malicious_content = "<?php system($_GET['cmd']); ?>"
        temp_file = tempfile.NamedTemporaryFile(mode='w', suffix='.php', delete=False)
        temp_file.write(malicious_content)
        temp_file.close()

        try:
            # Attempt to upload malicious file
            with open(temp_file.name, 'rb') as f:
                files = {'file': ('malicious.php', f, 'application/x-php')}
                data = {'description': 'Test upload'}

                response = requests.post(
                    f"{api_base_url}/api/v1/upload",
                    files=files,
                    data=data,
                    timeout=30
                )

                # Should reject malicious file types
                assert response.status_code in [400, 422, 403]

                # Check error message doesn't expose file path
                if response.status_code >= 400:
                    error_text = response.text.lower()
                    assert temp_file.name.lower() not in error_text

        finally:
            # Clean up temporary file
            os.unlink(temp_file.name)


class TestPenetrationTestingScenarios:
    """Penetration testing scenarios for Enhanced Cognee"""

    @pytest.fixture
    def api_base_url(self):
        """Base URL for Enhanced Cognee API"""
        return "http://localhost:28080"

    def test_brute_force_protection(self, api_base_url):
        """Test brute force attack protection"""

        username = "brute_force_target"
        common_passwords = [
            "password", "123456", "admin", "root", "user", "test",
            "password123", "123456789", "qwerty", "abc123",
            "password1", "admin123", "root123", "user123"
        ]

        failed_attempts = 0
        locked_out = False

        for password in common_passwords:
            login_data = {
                "username": username,
                "password": password
            }

            response = requests.post(
                f"{api_base_url}/api/v1/auth/login",
                json=login_data,
                timeout=10
            )

            if response.status_code in [401, 403]:
                failed_attempts += 1

            # Check for account lockout or rate limiting
            if response.status_code == 429 or "locked" in response.text.lower():
                locked_out = True
                break

            # Should stop trying after several failures due to rate limiting
            if failed_attempts > 5:
                break

        # Should implement brute force protection
        assert failed_attempts > 3 or locked_out, "No brute force protection detected"

    def test_session_hijacking_prevention(self, api_base_url):
        """Test session hijacking prevention measures"""

        # Create legitimate session
        user_data = {
            "username": f"session_user_{int(time.time())}",
            "email": f"session_user_{int(time.time())}@example.com",
            "password": "SecureSessionPassword123!"
        }

        # Register and login
        requests.post(f"{api_base_url}/api/v1/auth/register", json=user_data, timeout=30)
        login_response = requests.post(
            f"{api_base_url}/api/v1/auth/login",
            json={"username": user_data["username"], "password": user_data["password"]},
            timeout=30
        )

        if login_response.status_code == 200:
            token = login_response.json()["token"]

            # Test session validation measures
            # 1. Token should be signed and valid
            assert len(token.split(".")) == 3  # JWT structure

            # 2. Test token expiration
            headers = {"Authorization": f"Bearer {token}"}
            response = requests.get(f"{api_base_url}/api/v1/user/profile", headers=headers, timeout=30)

            assert response.status_code == 200, "Valid token rejected"

            # 3. Test token tampering detection
            tampered_token = token[:-10] + "tampered"
            headers = {"Authorization": f"Bearer {tampered_token}"}
            response = requests.get(f"{api_base_url}/api/v1/user/profile", headers=headers, timeout=30)

            assert response.status_code in [401, 403], "Tampered token accepted"

    def test_input_validation_bypass_attempts(self, api_base_url):
        """Test input validation bypass attempts"""

        # Test various input validation bypass techniques
        bypass_attempts = [
            # Unicode bypass
            {"username": "admin\x00", "password": "password"},
            {"username": "admin\u0000", "password": "password"},

            # Encoding bypass
            {"username": "admin%00", "password": "password"},
            {"username": "admin%2500", "password": "password"},

            # Double encoding
            {"username": "admin%252500", "password": "password"},

            # Case manipulation
            {"username": "ADMIN", "password": "password"},
            {"username": "AdMiN", "password": "password"},

            # Whitespace manipulation
            {"username": "admin ", "password": "password"},
            {"username": " admin", "password": "password"},
            {"username": "admin\t", "password": "password"}
        ]

        for attempt_data in bypass_attempts:
            response = requests.post(
                f"{api_base_url}/api/v1/auth/login",
                json=attempt_data,
                timeout=30
            )

            # Should not allow bypassing validation
            if response.status_code == 200:
                result = response.json()
                # If login succeeds, ensure it's legitimate
                assert result.get("username", "").lower().strip() == "admin"


if __name__ == "__main__":
    # Run tests directly
    pytest.main([__file__, "-v", "-s", "--tb=short"])